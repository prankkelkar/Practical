#include<iostream>
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<conio.h>

using namespace std;
//first convert the character string into postfix expression
int top=-1;
char a[100];

bool truth_table[100][12];//table with 100 rows and 12 columns
int count=0; //number of columns in the truth table
char prop[10];
int nprop=0;


void push(char c)
{
    a[++top]=c;
}

char pop()
{
    char x=a[top];
    top--;
    return x;
}

int getpriority(char ch)
{
    if(ch=='~')      return 4;  //not
    else if(ch=='^') return 3; //and
    else if(ch=='+') return 2; //or
    else if(ch=='#') return 1; //implication
    else if(ch=='(') return 5;
}

void convertToPostfix(char infix[],char postfix[])
{
    int plen=0;//length of postfix expression
    char ch,ch1;
    for(int i=0;i<strlen(infix);i++)
    {
        ch=infix[i];
        if(isalpha(ch))
        {

            postfix[plen++]=ch;
        }
        else if(ch=='('|| ch=='~' )
        {
            push(ch);
        }
        else if(ch==')')
        {
            while(a[top]!='(')
            {
                postfix[plen++]=pop();
            }
            pop();
        }
        else
        {
            if(top==-1)
            {
                push(ch);
            }
            else if((getpriority(ch)>=getpriority(a[top]))||a[top]=='(')
            {
                push(ch);
            }
            else
            {
                while(getpriority(ch)<=getpriority(a[top]))
                {
                    ch1=pop();
                    postfix[plen++]=ch1;
                }
                push(ch);
            }
        }

    }
    while(top!=-1)
    {
        postfix[plen++]=pop();
    }
    postfix[plen++]='\0';

}
////all the operations/////////////

int getindex(char ch)
{
    for(int i=0;i<nprop;i++)
        if(prop[i]==ch)
            return i;
}
void donotOperation(char ch)
{
    int index;
    if(ch!='~')
        index=getindex(ch);
    else
        index=count-1;

    for(int i=0;i<pow(2,nprop);i++)
    {
        if( truth_table[i][index]==1)
            truth_table[i][count]=0;
        else
            truth_table[i][count]=1;
    }
    count=count+1;
}

void doAndOperation(char ch1,char ch2)
{
    int ind1,ind2;

    if(ch1=='^'&& ch2=='^')
    {
        ind1=count-1;
        ind2=count-2;
    }
    else if(ch1=='^' && ch2!='^')
    {
        ind1=count-1;
        ind2=getindex(ch2);
    }
    else if(ch1!='^' && ch2=='^')
    {
        ind2=count-1;
        ind1=getindex(ch1);
    }
    else
    {
        ind1=getindex(ch1);
        ind2=getindex(ch2);
    }

    for(int i=0;i<pow(2,nprop);i++)
    {
        truth_table[i][count]=truth_table[i][ind1] && truth_table[i][ind2];
    }
    count=count+1;
}

void doOrOperation(char ch1,char ch2)
{
    int ind1,ind2;

    if(ch1=='+'&& ch2=='+')
    {
        ind1=count-1;
        ind2=count-2;
    }
    else if(ch1=='+' && ch2!='+')
    {
        ind1=count-1;
        ind2=getindex(ch2);
    }
    else if(ch1!='+' && ch2=='+')
    {
        ind2=count-1;
        ind1=getindex(ch1);
    }
    else
    {
        ind1=getindex(ch1);
        ind2=getindex(ch2);
    }

    for(int i=0;i<pow(2,nprop);i++)
    {
        truth_table[i][count]=truth_table[i][ind1] || truth_table[i][ind2];
    }
    count=count+1;
}

void doImplication(char ch1,char ch2)
{
    int ind1,ind2;

    if(ch1=='#'&& ch2=='#')
    {
        ind1=count-2;
        ind2=count-1;
    }
    else if(ch1=='#' && ch2!='#')
    {
        ind2=count-1;
        ind1=getindex(ch2);
    }
    else if(ch1!='#' && ch2=='#')
    {
        ind1=count-1;
        ind2=getindex(ch1);
    }
    else
    {
        ind1=getindex(ch2);
        ind2=getindex(ch1);
    }

    for(int i=0;i<pow(2,nprop);i++)
    {
        if(truth_table[i][ind1]==0)
        {
            truth_table[i][count]=1;
        }
        else
        {
            truth_table[i][count]=truth_table[i][ind2];
        }
    }
    count=count+1;
}


int main()
{
    char infix[30],postfix[30];
    int i,flag=0;


    cout<<"Enter a well formed formula\n";
    cin>>infix;

    convertToPostfix(infix,postfix);
    cout<<"the postfix is ";
    cout<<postfix<<endl;

//////finding out number of unique proposition symbols///
    for(i=0;i<strlen(infix);i++)
    {
        if(isalpha(infix[i]))
        {
            flag=0;
            for(int j=0;j<nprop;j++)
            {
               if(prop[j]==infix[i])
               {
                flag=1;
                break;
               }
             }
            if(flag==0)
                prop[nprop++]=infix[i];
        }

    }

/////construct the truth table/////////////////////
   int num_cols=0,j,temp=nprop,old_index;
   while(num_cols!=nprop)
   {
       old_index=0;
       for(i=0;i<pow(2,num_cols);i++)
       {
           for(j=0;j<pow(2,temp)/2;j++)
           {
               truth_table[j+old_index][num_cols]=0;
           }
           while(j<pow(2,temp))
           {
               truth_table[j+old_index][num_cols]=1;
               j++;
           }
           old_index+=j;
       }
       temp--;
       num_cols++;
   }
   count =num_cols;
   cout<<endl;

/////////////////////////////////////////////////////
//evaluating the postfix expression
top=-1;
char oper1,oper2,ch;
for(i=0;i<strlen(postfix);i++)
{
    ch=postfix[i];
    if(isalpha(ch))
        push(ch);
    else if(ch=='~')
    {
        oper1=pop();
        if(isalpha(oper1))
             donotOperation(oper1);
        else
            donotOperation('~');

        push('~');
    }
    else if(ch=='^')
    {
        oper1=pop();
        oper2=pop();
        if(isalpha(oper1)&& isalpha(oper2))
             doAndOperation(oper1,oper2);
        else if(isalpha(oper1) && !isalpha(oper2))
            doAndOperation(oper1,'^');
        else if(!isalpha(oper1) && isalpha(oper2))
            doAndOperation('^',oper2);
        else
            doAndOperation('^','^');

        push('^');
    }
     else if(ch=='+')
    {
        oper1=pop();
        oper2=pop();
        if(isalpha(oper1)&& isalpha(oper2))
             doOrOperation(oper1,oper2);
        else if(isalpha(oper1) && !isalpha(oper2))
            doOrOperation(oper1,'+');
        else if(!isalpha(oper1) && isalpha(oper2))
            doOrOperation('+',oper2);
        else
            doOrOperation('+','+');

        push('+');
    }
    else if(ch=='#')
    {
        oper1=pop();
        oper2=pop();
        if(isalpha(oper1)&& isalpha(oper2))
             doImplication(oper1,oper2);
        else if(isalpha(oper1) && !isalpha(oper2))
            doImplication(oper1,'#');
        else if(!isalpha(oper1) && isalpha(oper2))
            doImplication('#',oper2);
        else
            doImplication('#','#');

        push('#');
    }
}
////////////////////////
int isvalid=0;
for(i=0;i<pow(2,nprop);i++)
   {
       for(j=0;j<count;j++)
       {
          cout<<truth_table[i][j]<<"\t";
       }
       cout<<endl;
   }

for(j=0;j<pow(2,nprop);j++)
{
    if(truth_table[j][count-1]==1)
       {
           isvalid=1;
       }
    else
    {
        isvalid=0;
        break;
    }
}
if(isvalid==1)
{
    cout<<"\nThe formula is a valid formula\n";
}
else
{
    isvalid=0;
    for(j=0;j<pow(2,nprop);j++)
    {
    if(truth_table[j][count-1]==0)
       isvalid=1;
    else
        {
         isvalid=0;
         cout<<"\nSatisfiable formula\n";
         break;
        }
    }
    if(isvalid)
    {
        cout<<"\nUnsatisfiable formula\n";
    }
}
}
 
output:-
Enter a well formed formula
a.b#~c
the postfix is ab.c~#

0       0       0       1       1
0       0       1       0       1
0       1       0       1       1
0       1       1       0       0
1       0       0       1       1
1       0       1       0       1
1       1       0       1       1
1       1       1       0       0

Satisfiable formula